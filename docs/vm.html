<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>vm.md</title>
    <link rel="stylesheet" href="assets/style.css">
</head>

<body>
    <textarea id="source">
    
# DevOps avec des VM

* Contexte
* Architecture initiale
* La création d'un livrable
* La création des VM
* Le déploiement de l'application
* Que manque-t'il?
* L'incontournable zone d'hébergement

---

## Contexte

Nous allons voir en pratique comment se passe le déploiement d'une application **as code** sur des VM linux en déployant :

* [PostgreSQL](https://www.postgresql.org/) avec l'extension [PostGIS](https://postgis.net/) pour stocker des données géographiques.
* [GeoServer](https://geoserver.org/) pour diffuser ces données en WMS et WFS.

Nous appelerons le système résultant **GeoStack** (afin d'avoir un nom de base pour le dépôt dédié au déploiement : `geostack-deploy`)

---

## Architecture initiale

Nous commencerons par l'architecture triviale suivante :

![GeoStack 0.1](schema/geostack-0.1.png)

Nous en étudierons les limites par la suite.

---

## La création d'un livrable (1/4)

### Ne pas construire l'application en PRODUCTION

<span style="color: red; font-weight">Construire une application sur la PRODUCTION amène de nombreux problèmes :</span>

* Le risque de **ne pas pouvoir redéployer l'application en cas de problème** (ex : disparition d'une dépendance, indisponibilité d'un service,...)
* Une augmentation de la durée du déploiement
* La construction sur chaque instance.
* ...

NB : L'utilisation de fichier `package-lock.json`, `composer.lock`,... ne vous protégera que contre une montée en version innatendue des dépendances.

---

## La création d'un livrable (2/4)

### Produire et stocker un livrable à déployer

Pour le déploiement d'une application en PRODUCTION, il est important de :

* **Tagger une version** au niveau du gestionnaire de code source (ex : `v0.1.0`).
* **Produire un livrable** pour cette version du code.
* [Stocker ce livrable](annexe/stockage-artefact.html).
* Déployer en PRODUCTION un livrable stocké en lieu sûr.

(c.f. [Les 12 facteurs - V. Assemblez, publiez, exécutez](https://12factor.net/fr/build-release-run))

> Ce principe n'interdit pas de déployer en continu une version correspondant à la branche principale dans un environnement de DEV.

---

## La création d'un livrable (3/4)

### Choisir des services déjà packagés

Dans le cas présent, nous avons cette chance :

* [PostgreSQL](https://www.postgresql.org/download/) met à disposition des binaires pour différents systèmes. Nous avons même un dépôt [apt.postgresql.org](http://apt.postgresql.org/) qui permettra d'utiliser `apt-get install` et `apt-get upgrade`
* [GeoServer](https://geoserver.org/release/stable/) met lui aussi à disposition des livrables prêts à l'emploi.

---

## La création d'un livrable (4/4)

### Packager sa propre application

Dans le cas où il convient de créer un livrable pour sa propre application, on remarquera que :

* Il existe une **grande variété de formats de livrables possibles** fonction des technologies et OS cible (c.f. [format supportés par Nexus qui permet de créer différents types de dépôt](https://help.sonatype.com/repomanager3/nexus-repository-administration/formats) )
* Packager des applications telles PostgreSQL est un métier (construire et maintenir des .deb ou .rpm dans les règles de l'art n'est pas trivial).
* Dans le cas des **langages interprétés** (NodeJS, PHP...) :
  * Nous pourrons nous contenter en guise de livrable d'une simple archive (.zip, du code et de ses dépendances avec **le code de la version + les dépendances**
  * Nous pourrons aussi facilement produire des .deb ou .rpm avec des outils tels [FPM](https://fpm.readthedocs.io)

Nous n'entrerons pas trop dans le détail (*spoiler* : nous verrons comment l'utilisation de conteneurs solutionne ce problème)

---

## La création des VM (1/4)

### La variété des API

Il existe une grande variétés d'offres d'hébergement offrant une API permettant de contrôler :

* Les machines virtuelles (*compute*)
* Les réseaux privés (*network*)
* Le stockage (*storage*)
* L'exposition de service (*Load Balancer*)
* Un nom de domaine / DNS (1)
* ...

Nous trouverons des **concepts spécifiques à chaque solution dans ces API** (c.f. [API OVHCloud](https://api.us.ovhcloud.com/console/), [API Scaleway](https://developers.scaleway.com/en/), [DigitalOcean API (2.0)](https://docs.digitalocean.com/reference/api/api-reference/)...)

> (1) Particulièrement pratique pour générer des certificats wildcard [LetsEncrypt](https://letsencrypt.org/fr/) avec [lego](https://go-acme.github.io/lego/dns/)

---

## La création des VM (2/4)

### Terraform

Pour **gérer une infrastructure "as code" en production** sans programmer les appels à ces API, nous pourrions nous appuyer sur **[Terraform](https://www.terraform.io/intro#how-does-terraform-work)** qui apporte :

* Un **langage déclaratif** pour la création des ressources (machine virtuelle, réseau,...)
* Le support d'un [grand nombre de **fournisseurs**](https://registry.terraform.io/browse/providers) dont :
  * Les clouds publics : [AWS](https://registry.terraform.io/providers/hashicorp/aws/latest/docs), [Azure](https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs), [Google Cloud Platform](https://registry.terraform.io/providers/hashicorp/google/latest),...
  * Les clouds privés : [vsphere](https://registry.terraform.io/providers/hashicorp/vsphere/latest/docs), [openstack](https://registry.terraform.io/providers/terraform-provider-openstack/openstack/latest/docs),...


Nous nous contenterons de survoler quelques exemples et noterons que **Terraform n'est pas stateless** (il convient de [configurer un backend pour le stockage de l'état du système](https://www.terraform.io/language/settings/backends/configuration))

---

## La création des VM (3/4)

### Vagrant (1/2)

Pour la suite, nous allons plutôt utiliser [**Vagrant**](https://www.vagrantup.com/) qui est lui aussi développé par [HashiCorp](https://www.hashicorp.com/) et qui est l'équivalent de [Terraform](https://www.terraform.io/) pour les environnements de développement.

Nous allons analyser et utiliser le dépôt [mborne/vagrantbox](https://github.com/mborne/vagrantbox#vagrantbox) pour **démarrer des VM en une commande `vagrant up` à partir d'un fichier [Vagrantfile](https://github.com/mborne/vagrantbox/blob/master/Vagrantfile)**.

**Démonstration!** (en espérant que votre proxy de malheur m'épargne l'effet démo)

> La découverte de la plupart des outils de ce cours sera plus simple sur une machine perso connectée à internet via une box standard. Nous créons ici des VM [VirtualBox](https://www.virtualbox.org/) mais [Vagrant supporte d'autres fournisseurs (ex : KVM)](https://www.vagrantup.com/docs/providers).

---

## La création des VM (4/4)

### Vagrant (2/2)

Nous soulignerons que :

* La principale difficulté traitée dans ce dépôt est l'utilisation optionnelle d'un proxy sortant avec le plugin [vagrant-proxyconf](https://rubygems.org/gems/vagrant-proxyconf/versions/1.5.2).
* Vous pourrez créer vos propres `Vagrantfile` en suivant [Vagrant - getting started](https://learn.hashicorp.com/collections/vagrant/getting-started) :

```bash
vagrant init ubuntu/focal64
# lire et adapter le Vagrantfile généré...
vagrant up
```
* Vous trouverez de nombreux tutorials et [cheat sheet](https://gist.github.com/wpscholar/a49594e2e2b918f4d0c4#file-vagrant-cheat-sheet-md) en ligne pour utiliser cet outil.
* Vagrant sera aussi pratique pour créer une VM de DEV Linux avec un environnement graphique (`apt-get install ubuntu-desktop`)

---

## Le déploiement de l'application

### Les outils de gestion de configuration

Nous avons avec Vagrant et Terraform des outils capables de **créer nos VM as code**. Il nous reste à choisir une **gestion de configuration** pour **déployer et configurer nos applications**. Les plus connues sont :

* [Chef](https://docs.chef.io/platform_overview/)
* [Puppet](https://puppet.com/docs/puppet/6/puppet_overview.html)
* [Ansible](https://docs.ansible.com/ansible/latest/index.html)

---

## Le déploiement de l'application

### Le choix d'Ansible

Nous allons nous appuyer sur Ansible qui est une solution :

* [Libre, OpenSource et référencée dans le SILL (1)](https://sill.etalab.gouv.fr/software?name=Ansible)
* Basée sur l'utilisation du format YAML
* Implétentée en Python
* N'imposant pas un serveur de contrôle
* Permettant l'utilisation d'un serveur de contrôle ([AWX](https://github.com/ansible/awx#readme) par exemple).

> (1) [Socle interministériel de logiciels libres](https://sill.etalab.gouv.fr/software) où je ne retrouve plus chef et puppet un temps référencés (changement de licence?).

---

## Le déploiement de l'application

### Les principaux exécutables d'Ansible

Nous trouverons plusieurs exécutable avec Ansible :

* `ansible` qui permettra par exemple de lancer une commande sur les machines d'un inventaire
* `ansible-playbook` qui sera utilisée pour traiter un ensemble de tâches décrites au format YAML.
* `ansible-galaxy` qui permettra de télécharger des rôles partagés pour construire vos playbooks (voir [galaxy.ansible.com](https://galaxy.ansible.com/)).
* `ansible-vault` qui permettra de chiffrer des secrets.

---

## Le déploiement de l'application

### Le déploiement de GeoStack avec Ansible!

Présenter l'ensemble des [concepts ansible](https://docs.ansible.com/ansible/latest/network/getting_started/basic_concepts.html#basic-concepts) demanderait plusieurs séances.

Nous allons ici nous contenter d'une démonstration et de l'analyse d'un exemple [mborne/geostack-deploy - Déploiement de GeoStack avec ansible](https://github.com/mborne/geostack-deploy/blob/master/ansible/README.md#d%C3%A9ploiement-de-geostack-avec-ansible).

---

## Le déploiement de l'application

### Conclusion sur Ansible (1/2)

S'il faut réfléchir dans certains cas, nous soulignerons que bien souvent, la traduction des commandes en YAML est triviale :

```bash
sudo apt-get update
sudo apt-get install nginx
```

...devient :

```yaml
- name: Install nginx
  apt:
    name: nginx
    state: present
    update_cache: yes
```

---

## Le déploiement de l'application

### Conclusion sur Ansible (2/2)

Nous mémoriserons que Ansible permet de **décrire as code le déploiement d'une application avec un fichier YAML** qui sera exploitable comme suit :

```bash
# déploiement en QUALIF
ansible-playbook -i inventory/qualif mon-application.yml
```

Nous insisterons sur l'apport de Ansible pour :

* **Gérer des paramètres** en fonction des environnements (notamment par rapport à des scripts `install-geoserver.sh`)
* **Traiter des actions uniquement en cas de changement** (par exemple pour éviter des redémarrages inutiles)
* **Faciliter la rédaction et la maintenance des déploiements** (YAML et [nombreux modules disponibles](https://docs.ansible.com/ansible/2.9/modules/list_of_all_modules.html) rendant les procédures lisibles même sans connaissance d'Ansible).
* **Permettre la réutilisation de scripts de déploiements complet** (téléchargement de rôles avec `ansible-galaxy`, composition de playbook à partir de rôles,...)

---

## Que manque-t'il?

### La sécurité!

Nous ne pourrions pas procéder ainsi avec des VM exposées sur internet :

* Nous finirions sur [www.shodan.io](https://www.shodan.io/)
* Un des nombreux bots qui scannent le web testerait sans relâche nos VM

Il faudrait par exemple :

* Configurer un pare-feu local (par exemple avec [ufw](https://doc.ubuntu-fr.org/ufw))
* Configurer [fail2ban](https://doc.ubuntu-fr.org/fail2ban) pour bloquer les attaques par force brute sur SSH.
* Blinder la configuration des VM ( c.f. [dev-sec.io - DevSec Hardening Framework](https://dev-sec.io/baselines/linux/) )
* ...

> On notera l'existence d'une alternative à [fail2ban](https://doc.ubuntu-fr.org/fail2ban) : [CrowdSec](https://github.com/crowdsecurity/crowdsec#readme) où les IP suspectent sont partagées. On s'assurera de respecter le [RGPD](https://www.cnil.fr/fr/rgpd-de-quoi-parle-t-on) avec ce type d'outil.

---

## Que manque-t'il?

### L'incontournable reverse proxy (1/2)

Il conviendrait à minima de passer sur une architecture du type suivant en ajoutant un reverse proxy ("lb") :

![GeoStack v0.2](schema/geostack-0.2.png)

---

### L'incontournable reverse proxy (2/2)

Avec un reverse proxy, nous pourrions par exemple :

* Exposer publiquement les seuls services WMS et WFS de GeoServer (`/wms`, `/wfs`)
* Exposer l'interface d'interface d'administration avec un filtrage par IP (`/geoserver`)

---

## Que manque-t'il?

### La mise en oeuvre de HTTPS

Tant que nous serons en HTTP, le mot de passe de l'administrateur GeoServer circulera en clair sur le réseau. Il conviendrait donc de mettre en oeuvre HTTPS pour y remédier.

Nous soulignerons que : 

* HTTPS pourrait être mis en oeuvre au niveau du reverse proxy
* La mise en oeuvre HTTPS requière l'achat d'un certificat ou la génération de celui-ci avec [Let's Encrypt](https://letsencrypt.org/fr/)
* Pour les services exposés sur INTERNET, il existe des outils pour tester et blinder la configuration de TLS (cyphers, entêtes de sécurité, chaîne de certification...) tels :
  * [https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/)
  * [www.sslshopper.com](https://www.sslshopper.com/),...
* Pour les services non exposés (intranet, RIE), il faudra maîtriser `openssl` pour diagnostiquer et détecter ces problèmes.

---

## Que manque-t'il?

### L'observabilité

Pour pouvoir exploiter ces deux composants, il faudrait :

* Configurer la **centralisation des logs**
* Configurer un **système de supervision**

---

## Que manque-t'il?

### Les sauvegardes


https://docs.geoserver.geo-solutions.it/edu/en/clustering/index.html#clustering-geoserver



---

## L'incontournable zone d'hébergement

### La nécessité de traiter globalement ces problèmes

Il est illusoire d'espérer traiter de manière homogène ces problématiques au niveau de chaque application. Traiter ces problématiques de manière efficace demandera la **mise en place d'une infrastructure** pour l'accueil des applications dont le nom variera entre :

* Zone d'hébergement
* Zone applicative
* *Landing zone* (AWS)
* Socle technique d'exploitation
* ...

---

## L'incontournable zone d'hébergement

### Les principaux composants

Dans la zone d'hébergement, nous trouverons par exemple :

* Un **Bastion SSH** pour l'accès aux VM par les administrateurs
* Un **Reverse Proxy / Load Balancer** communs aux applications
* Des **services supports** (SMTP, DNS,...) communs aux applications
* Un puits de logs
* Un système de supervision
* Un serveur de déploiement
* ...

---

## L'incontournable zone d'hébergement

### Une compatibilité avec DevOps à garantir...

En cas de **recours à une équipe dédiée ou un prestataire** pour construire cette zone d'hébergement, il conviendra de **s'assurer que la méthode permet l'automatisation des déploiements**.

Typiquement, s'il faut faire un ticket au prestataire pour mettre à jour la configuration du reverse proxy et que la prise en compte de votre demande est garantie sous 6 jours, vous serez limité (c.f. impact d'une limitation partielle dans la partie précédente)...

    </textarea>

    <script src="assets/remarkjs/remark-latest.min.js"></script>
    <script src="assets/jquery/jquery-3.3.1.min.js"></script>
    <script>
        var slideshow = remark.create();

        /* footer */
        $('.remark-slide-content').each(function (index, data) {
            var footer = '<span class="footer">ENSG - <a href="https://mborne.github.io/cours-devops/">Introduction DevOps</a>, Mickaël BORNE, Octobre 2022</span>';
            $(data).append(footer);
        });
    </script>

</body>

</html>